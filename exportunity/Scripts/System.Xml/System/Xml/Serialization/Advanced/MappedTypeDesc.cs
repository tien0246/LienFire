using System.CodeDom;
using System.Collections.Specialized;
using System.Xml.Schema;

namespace System.Xml.Serialization.Advanced;

internal class MappedTypeDesc
{
	private string name;

	private string ns;

	private XmlSchemaType xsdType;

	private XmlSchemaObject context;

	private string clrType;

	private SchemaImporterExtension extension;

	private CodeNamespace code;

	private bool exported;

	private StringCollection references;

	internal SchemaImporterExtension Extension => extension;

	internal string Name => clrType;

	internal StringCollection ReferencedAssemblies
	{
		get
		{
			if (references == null)
			{
				references = new StringCollection();
			}
			return references;
		}
	}

	internal MappedTypeDesc(string clrType, string name, string ns, XmlSchemaType xsdType, XmlSchemaObject context, SchemaImporterExtension extension, CodeNamespace code, StringCollection references)
	{
		this.clrType = clrType.Replace('+', '.');
		this.name = name;
		this.ns = ns;
		this.xsdType = xsdType;
		this.context = context;
		this.code = code;
		this.references = references;
		this.extension = extension;
	}

	internal CodeTypeDeclaration ExportTypeDefinition(CodeNamespace codeNamespace, CodeCompileUnit codeCompileUnit)
	{
		if (exported)
		{
			return null;
		}
		exported = true;
		foreach (CodeNamespaceImport import in code.Imports)
		{
			codeNamespace.Imports.Add(import);
		}
		CodeTypeDeclaration codeTypeDeclaration = null;
		string text = Res.GetString("This type definition was generated by {0} schema importer extension.", extension.GetType().FullName);
		foreach (CodeTypeDeclaration type in code.Types)
		{
			if (clrType == type.Name)
			{
				if (codeTypeDeclaration != null)
				{
					throw new InvalidOperationException(Res.GetString("Schema importer extension {0} generated duplicate type definitions: {1}.", extension.GetType().FullName, clrType));
				}
				codeTypeDeclaration = type;
			}
			type.Comments.Add(new CodeCommentStatement(text, docComment: false));
			codeNamespace.Types.Add(type);
		}
		if (codeCompileUnit != null)
		{
			StringEnumerator enumerator2 = ReferencedAssemblies.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					string current = enumerator2.Current;
					if (!codeCompileUnit.ReferencedAssemblies.Contains(current))
					{
						codeCompileUnit.ReferencedAssemblies.Add(current);
					}
				}
			}
			finally
			{
				if (enumerator2 is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
		}
		return codeTypeDeclaration;
	}
}
